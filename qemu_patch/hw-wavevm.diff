diff --git a/hw/meson.build b/hw/meson.build
index 010de7219..e2cd60b30 100644
--- a/hw/meson.build
+++ b/hw/meson.build
@@ -39,6 +39,7 @@ subdir('usb')
 subdir('vfio')
 subdir('virtio')
 subdir('watchdog')
+subdir('wavevm')
 subdir('xen')
 subdir('xenpv')
 
diff --git a/hw/wavevm/meson.build b/hw/wavevm/meson.build
new file mode 100644
index 000000000..1494f023f
--- /dev/null
+++ b/hw/wavevm/meson.build
@@ -0,0 +1,3 @@
+softmmu_ss.add(files(
+  'wavevm-block-hook.c',
+))
diff --git a/hw/wavevm/wavevm-block-hook.c b/hw/wavevm/wavevm-block-hook.c
new file mode 100644
index 000000000..b2af780be
--- /dev/null
+++ b/hw/wavevm/wavevm-block-hook.c
@@ -0,0 +1,44 @@
+#include "qemu/osdep.h"
+#include "qemu/iov.h"
+
+/*
+ * virtio-blk hook entry point. Returns 0 when the request is handled by the
+ * WaveVM IPC path. Returns -1 to let virtio-blk use its normal local path.
+ */
+int wavevm_blk_interceptor(uint64_t sector, QEMUIOVector *qiov, int is_write);
+
+extern int wvm_send_ipc_block_io(uint64_t lba, void *buf, uint32_t len, int is_write)
+    __attribute__((weak));
+
+int wavevm_blk_interceptor(uint64_t sector, QEMUIOVector *qiov, int is_write)
+{
+    size_t total_len = qiov->size;
+    uint8_t *linear_buf;
+    int ret;
+
+    if (total_len == 0 || total_len > UINT32_MAX) {
+        return -1;
+    }
+
+    linear_buf = g_malloc(total_len);
+    if (!linear_buf) {
+        return -1;
+    }
+
+    if (is_write) {
+        qemu_iovec_to_buf(qiov, 0, linear_buf, total_len);
+    }
+
+    if (!wvm_send_ipc_block_io) {
+        g_free(linear_buf);
+        return -1;
+    }
+
+    ret = wvm_send_ipc_block_io(sector, linear_buf, (uint32_t)total_len, is_write);
+    if (!is_write && ret == 0) {
+        qemu_iovec_from_buf(qiov, 0, linear_buf, total_len);
+    }
+
+    g_free(linear_buf);
+    return ret;
+}
